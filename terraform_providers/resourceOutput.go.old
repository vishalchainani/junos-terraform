package main

import (
	"container/list"
	"context"
	"encoding/xml"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// Junos XML Hierarchy
type xmlInterfaces struct {
	XMLName xml.Name `xml:"configuration"`
	Groups  struct {
		XMLName   xml.Name `xml:"groups"`
		Name      string   `xml:"name"`
		Interface struct {
			XMLName      xml.Name `xml:"interface"`
			Name         *string  `xml:"name,omitempty"`
			Description  *string  `xml:"description,omitempty"`
			Vlan_tagging *bool    `xml:"vlan-tagging,omitempty"`
			Mtu          *int64   `xml:"mtu,omitempty"`
			Unit         struct {
				Name        *string `xml:"name,omitempty"`
				Description *string `xml:"description,omitempty"`
				Vlan_id     *string `xml:"vlan-id,omitempty"`
				Family      struct {
					Inet struct {
						Address struct {
							Name *string `xml:"name,omitempty"`
						}
					}
					Inet6 struct {
						Address struct {
							Name *string `xml:"name,omitempty"`
						}
					}
				}
			}
		} `xml:"interfaces>interface"`
	} `xml:"groups"`
}

// Collecting objects from the .tf file
type InterfacesModel struct {
	ResourceName types.String `tfsdk:"resource_name"`
	Name         types.String `tfsdk:"name"`
	Description  types.String `tfsdk:"description"`
	Mtu          types.Int64  `tfsdk:"mtu"`
	Vlan_tagging types.Bool   `tfsdk:"vlan-tagging"`
	Unit         types.List   `tfsdk:"unit"`
}

func (o InterfacesModel) AttrTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"name":        types.StringType,
		"description": types.StringType,
		"mtu":         types.Int64Type,
		"unit":        types.ListType{ElemType: types.ObjectType{AttrTypes: UnitModel{}.AttrTypes()}},
	}
}
func (o InterfacesModel) Attributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"name": schema.StringAttribute{
			Optional:            true,
			MarkdownDescription: "xpth is `config.Groups.Interface.Name",
		},
		"description": schema.StringAttribute{
			Optional:            true,
			MarkdownDescription: "xpth is `config.Groups.Interface.Description",
		},
		"mtu": schema.Int64Attribute{
			Optional:            true,
			MarkdownDescription: "xpath is `config.Groups.Interface.Mtu",
		},
		"unit": schema.ListNestedAttribute{
			Optional: true,
			NestedObject: schema.NestedAttributeObject{
				Attributes: UnitModel{}.Attributes(),
			},
		},
	}
}

type UnitModel struct {
	Name        types.String `tfsdk:"name"`
	Description types.String `tfsdk:"description"`
	Vlan_id     types.String `tfsdk:"vlan-id"`
	Family      types.List   `tfsdk:"family"`
}

func (o UnitModel) AttrTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"name":        types.StringType,
		"description": types.StringType,
		"vlan-id":     types.StringType,
		"family":      types.ListType{ElemType: types.ObjectType{AttrTypes: FamilyModel{}.AttrTypes()}},
	}
}
func (o UnitModel) Attributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"name": schema.StringAttribute{
			Optional:            true,
			MarkdownDescription: "xpath is `config.Groups.Unit.Name`",
		},
		"description": schema.StringAttribute{
			Optional:            true,
			MarkdownDescription: "xpath is `config.Groups.Unit.Description`",
		},
		"vlan-id": schema.StringAttribute{
			Optional:            true,
			MarkdownDescription: "xpath is `config.Groups.Unit.Vlan-id`",
		},
		"family": schema.ListNestedAttribute{
			Optional: true,
			NestedObject: schema.NestedAttributeObject{
				Attributes: FamilyModel{}.Attributes(),
			},
		},
	}
}

type FamilyModel struct {
	Inet  types.List `tfsdk:"inet"`
	Inet6 types.List `tfsdk:"inet6"`
}

func (o FamilyModel) AttrTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"inet":  types.ListType{ElemType: types.ObjectType{AttrTypes: InetModel{}.AttrTypes()}},
		"inet6": types.ListType{ElemType: types.ObjectType{AttrTypes: Inet6Model{}.AttrTypes()}},
	}

}
func (o FamilyModel) Attributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"inet": schema.ListNestedAttribute{
			Optional: true,
			NestedObject: schema.NestedAttributeObject{
				Attributes: InetModel{}.Attributes(),
			},
		},
		"inet6": schema.ListNestedAttribute{
			Optional: true,
			NestedObject: schema.NestedAttributeObject{
				Attributes: Inet6Model{}.Attributes(),
			},
		},
	}
}

type InetModel struct {
	Address types.List `tfsdk:"address"`
}

func (o InetModel) AttrTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"address": types.StringType,
	}
}
func (o InetModel) Attributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"address": schema.ListNestedAttribute{
			Optional: true,
			NestedObject: schema.NestedAttributeObject{
				Attributes: AddressModel{}.Attributes(),
			},
		},
	}
}

type AddressModel struct {
	Name types.String `tfsdk:"name"`
}

func (o AddressModel) AttrTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"name": types.StringType,
	}
}
func (o AddressModel) Attributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"name": schema.StringAttribute{
			Optional:            true,
			MarkdownDescription: "xpath is `config.Groups.Address.Name`",
		},
	}
}

type Inet6Model struct {
	Address types.List `tfsdk:"address"`
}

func (o Inet6Model) AttrTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"address": types.StringType,
	}
}
func (o Inet6Model) Attributes() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"address": schema.ListNestedAttribute{
			Optional: true,
			NestedObject: schema.NestedAttributeObject{
				Attributes: AddressModel{}.Attributes(),
			},
		},
	}
}

// Collects the data for the crud work
type resourceInterfaces struct {
	client ProviderConfig
}

func (r *resourceInterfaces) Configure(_ context.Context, req resource.ConfigureRequest, _ *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	r.client = req.ProviderData.(ProviderConfig)
}

// Metadata implements resource.Resource.
func (r *resourceInterfaces) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_Interfaces"
}

// Schema implements resource.Resource.
func (r *resourceInterfaces) Schema(_ context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Attributes: map[string]schema.Attribute{
			"resource_name": schema.StringAttribute{
				Required:      true,
				PlanModifiers: []planmodifier.String{stringplanmodifier.RequiresReplace()},
			},
			"interface": schema.ListNestedAttribute{
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: InterfacesModel{}.Attributes(),
				},
			},
		},
	}
}

// Create implements resource.Resource.
func (r *resourceInterfaces) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {

	// Get the Interfaces Model data and set
	var plan InterfacesModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	// Check for errors
	if resp.Diagnostics.HasError() {
		return
	}

	var config xmlInterfaces
	config.Groups.Name = plan.ResourceName.ValueString()
	config.Groups.Interface.Name = plan.Name.ValueStringPointer()
	config.Groups.Interface.Description = plan.Description.ValueStringPointer()
	config.Groups.Interface.Vlan_tagging = plan.Vlan_tagging.ValueBoolPointer()
	config.Groups.Interface.Mtu = plan.Mtu.ValueInt64Pointer()

	var units []UnitModel
	resp.Diagnostics.Append(plan.Unit.ElementsAs(ctx, &units, false)...)
	if resp.Diagnostics.HasError() {
		return
	}
	config.Groups.Interface.Unit.Name = units[0].Name.ValueStringPointer()
	config.Groups.Interface.Unit.Description = units[0].Description.ValueStringPointer()
	config.Groups.Interface.Unit.Vlan_id = units[0].Vlan_id.ValueStringPointer()

	var familys []FamilyModel
	resp.Diagnostics.Append(units[0].Family.ElementsAs(ctx, &familys, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var inets []InetModel
	resp.Diagnostics.Append(familys[0].Inet.ElementsAs(ctx, &inets, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var addresss []AddressModel
	resp.Diagnostics.Append(inets[0].Address.ElementsAs(ctx, &addresss, false)...)
	if resp.Diagnostics.HasError() {
		return
	}
	config.Groups.Interface.Unit.Family.Inet.Address.Name = addresss[0].Name.ValueStringPointer()

	var inet6s []Inet6Model
	resp.Diagnostics.Append(familys[0].Inet6.ElementsAs(ctx, &inet6s, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(inet6s[0].Address.ElementsAs(ctx, &addresss, false)...)
	if resp.Diagnostics.HasError() {
		return
	}
	config.Groups.Interface.Unit.Family.Inet6.Address.Name = addresss[0].Name.ValueStringPointer()

	err := r.client.SendTransaction("", config, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed while Sending", err.Error())
		return
	}
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

// Read implements resource.Resource.
func (r *resourceInterfaces) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	// Get the data and set
	var state InterfacesModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	// Check for errors
	if resp.Diagnostics.HasError() {
		return
	}

	// Marshall group and check
	var config xmlInterfaces
	id := config.Groups.Name
	err := r.client.MarshalGroup(id, config)
	if err != nil {
		resp.Diagnostics.AddError("Failed while Reading", err.Error())
		return
	}
	var newstate InterfacesModel
	newstate.ResourceName = types.StringValue(config.Groups.Name)
	newstate.Name = types.StringPointerValue(config.Groups.Interface.Name)
	newstate.Description = types.StringPointerValue(config.Groups.Interface.Description)
	newstate.Vlan_tagging = types.BoolPointerValue(config.Groups.Interface.Vlan_tagging)
	newstate.Mtu = types.Int64PointerValue(config.Groups.Interface.Mtu)
	newstate.Unit = types.ListValueFrom(ctx)

	var units UnitModel

	units.Name = types.StringPointerValue(config.Groups.Interface.Unit.Name)
	units.Description = types.StringPointerValue(config.Groups.Interface.Unit.Description)
	units.Vlan_id = types.StringPointerValue(config.Groups.Interface.Unit.Vlan_id)
	units.Family  = types.ListType{ElemType: types.}

	var familys FamilyModel
	familys.Inet = ??

	var inets InetModel
	inets.Address = types.StringPointerValue(config.Groups.Interface.Unit.Family.Inet.Address.Name)

	var inet6s Inet6Model
	inet6s.Address = types.StringPointerValue(config.Groups.Interface.Unit.Family.Inet6.Address.Name)

	var ip_addr AddressModel
	ip_addr.Name = types.StringPointerValue(config.Groups.Interface.Unit.Family.Inet.Address.Name)


	if resp.Diagnostics.HasError() {
		return
	}

	if err := resp.State.Set(ctx, config.Groups.Interfaces.Interface.Name); err != nil {
		return
	}
	if err := resp.State.Set(ctx, config.Groups.Interfaces.Interface.Description); err != nil {
		return
	}
	if err := resp.State.Set(ctx, config.Groups.Interfaces.Interface.Vlan_tagging); err != nil {
		return
	}
	if err := resp.State.Set(ctx, config.Groups.Interfaces.Interface.Mtu); err != nil {
		return
	}
	if err := resp.State.Set(ctx, config.Groups.Interfaces.Interface.Unit); err != nil {
		return
	}
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update implements resource.Resource.
func (r *resourceInterfaces) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {

	// Get the Interfaces Model data and set
	var plan InterfacesModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	// Check for errors
	if resp.Diagnostics.HasError() {
		return
	}

	var config xmlInterfaces
	config.Groups.Name = plan.ResourceName.ValueString()
	config.Groups.Interface.Name = plan.Name.ValueStringPointer()
	config.Groups.Interface.Description = plan.Description.ValueStringPointer()
	config.Groups.Interface.Vlan_tagging = plan.Vlan_tagging.ValueBoolPointer()
	config.Groups.Interface.Mtu = plan.Mtu.ValueInt64Pointer()

	var units []UnitModel
	resp.Diagnostics.Append(plan.Unit.ElementsAs(ctx, &units, false)...)
	if resp.Diagnostics.HasError() {
		return
	}
	config.Groups.Interface.Unit.Name = units[0].Name.ValueStringPointer()
	config.Groups.Interface.Unit.Description = units[0].Description.ValueStringPointer()
	config.Groups.Interface.Unit.Vlan_id = units[0].Vlan_id.ValueStringPointer()

	var familys []FamilyModel
	resp.Diagnostics.Append(units[0].Family.ElementsAs(ctx, &familys, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var inets []InetModel
	resp.Diagnostics.Append(familys[0].Inet.ElementsAs(ctx, &inets, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var addresss []AddressModel
	resp.Diagnostics.Append(inets[0].Address.ElementsAs(ctx, &addresss, false)...)
	if resp.Diagnostics.HasError() {
		return
	}
	config.Groups.Interface.Unit.Family.Inet.Address.Name = addresss[0].Name.ValueStringPointer()

	var inet6s []Inet6Model
	resp.Diagnostics.Append(familys[0].Inet6.ElementsAs(ctx, &inet6s, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(inet6s[0].Address.ElementsAs(ctx, &addresss, false)...)
	if resp.Diagnostics.HasError() {
		return
	}
	config.Groups.Interface.Unit.Family.Inet6.Address.Name = addresss[0].Name.ValueStringPointer()

	err := r.client.SendTransaction("", config, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed while Sending", err.Error())
		return
	}
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

// Delete implements resource.Resource.
func (r *resourceInterfaces) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state InterfacesModel
	d := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(d...)
	if resp.Diagnostics.HasError() {
		return
	}

	_, err := r.client.DeleteConfig(state.ResourceName.ValueString(), false)
	if err != nil {
		if strings.Contains(err.Error(), "ound") {
			return
		}
		resp.Diagnostics.AddError("Failed while deleting dile", err.Error())
		return
	}
}
